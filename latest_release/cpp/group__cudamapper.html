<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GenomeWorks: CUDA mapper package</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GenomeWorks
   &#160;<span id="projectnumber">0.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CUDA mapper package</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base docs for the cudamapper package (tbd)  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Index.html">claraparabricks::genomeworks::cudamapper::Index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Index.html" title="Index - manages mapping of (k,w)-kmer-representation and all its occurences.">Index</a> - manages mapping of (k,w)-kmer-representation and all its occurences.  <a href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1IndexHostCopyBase.html">claraparabricks::genomeworks::cudamapper::IndexHostCopyBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Matcher.html">claraparabricks::genomeworks::cudamapper::Matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Matcher.html" title="Matcher - base matcher.">Matcher</a> - base matcher.  <a href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Overlapper.html">claraparabricks::genomeworks::cudamapper::Overlapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1SketchElement.html">claraparabricks::genomeworks::cudamapper::SketchElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1SketchElement.html" title="SketchElement - Contains integer representation, position, direction and read id of a kmer.">SketchElement</a> - Contains integer representation, position, direction and read id of a kmer.  <a href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1SketchElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae66201c0667cc8428fe3a567a79d4af9"><td class="memItemLeft" align="right" valign="top"><a id="gae66201c0667cc8428fe3a567a79d4af9"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#gae66201c0667cc8428fe3a567a79d4af9">claraparabricks::genomeworks::cudamapper::Index::~Index</a> ()=default</td></tr>
<tr class="memdesc:gae66201c0667cc8428fe3a567a79d4af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor. <br /></td></tr>
<tr class="separator:gae66201c0667cc8428fe3a567a79d4af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed943d2e0a9c706ed46a2bf1a4899c4d"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classclaraparabricks_1_1genomeworks_1_1details_1_1buffer.html">device_buffer</a>&lt; representation_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#gaed943d2e0a9c706ed46a2bf1a4899c4d">claraparabricks::genomeworks::cudamapper::Index::representations</a> () const =0</td></tr>
<tr class="memdesc:gaed943d2e0a9c706ed46a2bf1a4899c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an array of representations of sketch elements  <a href="group__cudamapper.html#gaed943d2e0a9c706ed46a2bf1a4899c4d">More...</a><br /></td></tr>
<tr class="separator:gaed943d2e0a9c706ed46a2bf1a4899c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c953d45217acb55ef8ad6f09450d1b8"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classclaraparabricks_1_1genomeworks_1_1details_1_1buffer.html">device_buffer</a>&lt; read_id_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga8c953d45217acb55ef8ad6f09450d1b8">claraparabricks::genomeworks::cudamapper::Index::read_ids</a> () const =0</td></tr>
<tr class="memdesc:ga8c953d45217acb55ef8ad6f09450d1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an array of reads ids for sketch elements  <a href="group__cudamapper.html#ga8c953d45217acb55ef8ad6f09450d1b8">More...</a><br /></td></tr>
<tr class="separator:ga8c953d45217acb55ef8ad6f09450d1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29cef625e1b5bfcac9937dd06a3d5452"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classclaraparabricks_1_1genomeworks_1_1details_1_1buffer.html">device_buffer</a>&lt; position_in_read_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga29cef625e1b5bfcac9937dd06a3d5452">claraparabricks::genomeworks::cudamapper::Index::positions_in_reads</a> () const =0</td></tr>
<tr class="memdesc:ga29cef625e1b5bfcac9937dd06a3d5452"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an array of starting positions of sketch elements in their reads  <a href="group__cudamapper.html#ga29cef625e1b5bfcac9937dd06a3d5452">More...</a><br /></td></tr>
<tr class="separator:ga29cef625e1b5bfcac9937dd06a3d5452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf331310d832baa8f1d98c3e0b38f55e1"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classclaraparabricks_1_1genomeworks_1_1details_1_1buffer.html">device_buffer</a>&lt; <a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1SketchElement.html#afa33c55e7eb7a95cc5d9b7a18f546274">SketchElement::DirectionOfRepresentation</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#gaf331310d832baa8f1d98c3e0b38f55e1">claraparabricks::genomeworks::cudamapper::Index::directions_of_reads</a> () const =0</td></tr>
<tr class="memdesc:gaf331310d832baa8f1d98c3e0b38f55e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an array of directions in which sketch elements were read  <a href="group__cudamapper.html#gaf331310d832baa8f1d98c3e0b38f55e1">More...</a><br /></td></tr>
<tr class="separator:gaf331310d832baa8f1d98c3e0b38f55e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9012be3598ec4d979289fa5954c1bb7d"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classclaraparabricks_1_1genomeworks_1_1details_1_1buffer.html">device_buffer</a>&lt; representation_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga9012be3598ec4d979289fa5954c1bb7d">claraparabricks::genomeworks::cudamapper::Index::unique_representations</a> () const =0</td></tr>
<tr class="memdesc:ga9012be3598ec4d979289fa5954c1bb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an array where each representation is recorder only once, sorted by representation  <a href="group__cudamapper.html#ga9012be3598ec4d979289fa5954c1bb7d">More...</a><br /></td></tr>
<tr class="separator:ga9012be3598ec4d979289fa5954c1bb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6e120ef97a1c4af963008b5fcc82403"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classclaraparabricks_1_1genomeworks_1_1details_1_1buffer.html">device_buffer</a>&lt; std::uint32_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#gaf6e120ef97a1c4af963008b5fcc82403">claraparabricks::genomeworks::cudamapper::Index::first_occurrence_of_representations</a> () const =0</td></tr>
<tr class="memdesc:gaf6e120ef97a1c4af963008b5fcc82403"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns first occurrence of corresponding representation from <a class="el" href="group__cudamapper.html#ga9012be3598ec4d979289fa5954c1bb7d" title="returns an array where each representation is recorder only once, sorted by representation">unique_representations()</a> in data arrays  <a href="group__cudamapper.html#gaf6e120ef97a1c4af963008b5fcc82403">More...</a><br /></td></tr>
<tr class="separator:gaf6e120ef97a1c4af963008b5fcc82403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab769e543662cab81e53e8ca7e1ab56f9"><td class="memItemLeft" align="right" valign="top">virtual read_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#gab769e543662cab81e53e8ca7e1ab56f9">claraparabricks::genomeworks::cudamapper::Index::number_of_reads</a> () const =0</td></tr>
<tr class="memdesc:gab769e543662cab81e53e8ca7e1ab56f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns number of reads in input data  <a href="group__cudamapper.html#gab769e543662cab81e53e8ca7e1ab56f9">More...</a><br /></td></tr>
<tr class="separator:gab769e543662cab81e53e8ca7e1ab56f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf19ac4dc5ee6809368955500e4023e6d"><td class="memItemLeft" align="right" valign="top">virtual read_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#gaf19ac4dc5ee6809368955500e4023e6d">claraparabricks::genomeworks::cudamapper::Index::smallest_read_id</a> () const =0</td></tr>
<tr class="memdesc:gaf19ac4dc5ee6809368955500e4023e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns smallest read_id in index  <a href="group__cudamapper.html#gaf19ac4dc5ee6809368955500e4023e6d">More...</a><br /></td></tr>
<tr class="separator:gaf19ac4dc5ee6809368955500e4023e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f69e6fa88662eff1ab7c87edfc7ef32"><td class="memItemLeft" align="right" valign="top">virtual read_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga7f69e6fa88662eff1ab7c87edfc7ef32">claraparabricks::genomeworks::cudamapper::Index::largest_read_id</a> () const =0</td></tr>
<tr class="memdesc:ga7f69e6fa88662eff1ab7c87edfc7ef32"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns largest read_id in index  <a href="group__cudamapper.html#ga7f69e6fa88662eff1ab7c87edfc7ef32">More...</a><br /></td></tr>
<tr class="separator:ga7f69e6fa88662eff1ab7c87edfc7ef32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca45bc654ce38bc06c960a432a641916"><td class="memItemLeft" align="right" valign="top">virtual position_in_read_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#gaca45bc654ce38bc06c960a432a641916">claraparabricks::genomeworks::cudamapper::Index::number_of_basepairs_in_longest_read</a> () const =0</td></tr>
<tr class="memdesc:gaca45bc654ce38bc06c960a432a641916"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns length of the longest read in this index  <a href="group__cudamapper.html#gaca45bc654ce38bc06c960a432a641916">More...</a><br /></td></tr>
<tr class="separator:gaca45bc654ce38bc06c960a432a641916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98eb05b517a7c7a9fe85164d265841ed"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga98eb05b517a7c7a9fe85164d265841ed">claraparabricks::genomeworks::cudamapper::Index::maximum_kmer_size</a> ()</td></tr>
<tr class="memdesc:ga98eb05b517a7c7a9fe85164d265841ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum kmer length allowable.  <a href="group__cudamapper.html#ga98eb05b517a7c7a9fe85164d265841ed">More...</a><br /></td></tr>
<tr class="separator:ga98eb05b517a7c7a9fe85164d265841ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94383d9d95a69977f72ed3b05162f874"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Index.html">Index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga94383d9d95a69977f72ed3b05162f874">claraparabricks::genomeworks::cudamapper::Index::create_index</a> (<a class="el" href="classclaraparabricks_1_1genomeworks_1_1CudaMallocAllocator.html">DefaultDeviceAllocator</a> allocator, const <a class="el" href="classclaraparabricks_1_1genomeworks_1_1io_1_1FastaParser.html">io::FastaParser</a> &amp;parser, const read_id_t first_read_id, const read_id_t past_the_last_read_id, const std::uint64_t kmer_size, const std::uint64_t window_size, const bool hash_representations=true, const double filtering_parameter=1.0, const cudaStream_t cuda_stream=0)</td></tr>
<tr class="memdesc:ga94383d9d95a69977f72ed3b05162f874"><td class="mdescLeft">&#160;</td><td class="mdescRight">generates a mapping of (k,w)-kmer-representation to all of its occurrences for one or more sequences  <a href="group__cudamapper.html#ga94383d9d95a69977f72ed3b05162f874">More...</a><br /></td></tr>
<tr class="separator:ga94383d9d95a69977f72ed3b05162f874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf16c3675fb7b4d2ea891efaed8d4d4b"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Index.html">Index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#gadf16c3675fb7b4d2ea891efaed8d4d4b">claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::copy_index_to_device</a> (<a class="el" href="classclaraparabricks_1_1genomeworks_1_1CudaMallocAllocator.html">DefaultDeviceAllocator</a> allocator, const cudaStream_t cuda_stream=0) const =0</td></tr>
<tr class="memdesc:gadf16c3675fb7b4d2ea891efaed8d4d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy cached index vectors from the host and create an object of <a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Index.html" title="Index - manages mapping of (k,w)-kmer-representation and all its occurences.">Index</a> on GPU  <a href="group__cudamapper.html#gadf16c3675fb7b4d2ea891efaed8d4d4b">More...</a><br /></td></tr>
<tr class="separator:gadf16c3675fb7b4d2ea891efaed8d4d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34854e2fcd0937f077955532ef907947"><td class="memItemLeft" align="right" valign="top"><a id="ga34854e2fcd0937f077955532ef907947"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga34854e2fcd0937f077955532ef907947">claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::~IndexHostCopyBase</a> ()=default</td></tr>
<tr class="memdesc:ga34854e2fcd0937f077955532ef907947"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual destructor <br /></td></tr>
<tr class="separator:ga34854e2fcd0937f077955532ef907947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23dde7ca05b079b1d5b6f3cbae5462a4"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; representation_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga23dde7ca05b079b1d5b6f3cbae5462a4">claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::representations</a> () const =0</td></tr>
<tr class="memdesc:ga23dde7ca05b079b1d5b6f3cbae5462a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an array of representations of sketch elements (stored on host)  <a href="group__cudamapper.html#ga23dde7ca05b079b1d5b6f3cbae5462a4">More...</a><br /></td></tr>
<tr class="separator:ga23dde7ca05b079b1d5b6f3cbae5462a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga873f6ab8eb381b6231463aa2d3f0e753"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; read_id_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga873f6ab8eb381b6231463aa2d3f0e753">claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::read_ids</a> () const =0</td></tr>
<tr class="memdesc:ga873f6ab8eb381b6231463aa2d3f0e753"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an array of reads ids for sketch elements (stored on host)  <a href="group__cudamapper.html#ga873f6ab8eb381b6231463aa2d3f0e753">More...</a><br /></td></tr>
<tr class="separator:ga873f6ab8eb381b6231463aa2d3f0e753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b833e24986c9d3371ab4e5028e7330c"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; position_in_read_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga9b833e24986c9d3371ab4e5028e7330c">claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::positions_in_reads</a> () const =0</td></tr>
<tr class="memdesc:ga9b833e24986c9d3371ab4e5028e7330c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an array of starting positions of sketch elements in their reads (stored on host)  <a href="group__cudamapper.html#ga9b833e24986c9d3371ab4e5028e7330c">More...</a><br /></td></tr>
<tr class="separator:ga9b833e24986c9d3371ab4e5028e7330c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9e6aa4523e65918eb9b3b468b80335e"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; <a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1SketchElement.html#afa33c55e7eb7a95cc5d9b7a18f546274">SketchElement::DirectionOfRepresentation</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#gab9e6aa4523e65918eb9b3b468b80335e">claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::directions_of_reads</a> () const =0</td></tr>
<tr class="memdesc:gab9e6aa4523e65918eb9b3b468b80335e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an array of directions in which sketch elements were read (stored on host)  <a href="group__cudamapper.html#gab9e6aa4523e65918eb9b3b468b80335e">More...</a><br /></td></tr>
<tr class="separator:gab9e6aa4523e65918eb9b3b468b80335e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30f0292e61c1f6d1062c73f7043e91a6"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; representation_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga30f0292e61c1f6d1062c73f7043e91a6">claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::unique_representations</a> () const =0</td></tr>
<tr class="memdesc:ga30f0292e61c1f6d1062c73f7043e91a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an array where each representation is recorded only once, sorted by representation (stored on host)  <a href="group__cudamapper.html#ga30f0292e61c1f6d1062c73f7043e91a6">More...</a><br /></td></tr>
<tr class="separator:ga30f0292e61c1f6d1062c73f7043e91a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0141760d12af38d0c6daea48222f8b8"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; std::uint32_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#gae0141760d12af38d0c6daea48222f8b8">claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::first_occurrence_of_representations</a> () const =0</td></tr>
<tr class="memdesc:gae0141760d12af38d0c6daea48222f8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns first occurrence of corresponding representation from <a class="el" href="group__cudamapper.html#ga30f0292e61c1f6d1062c73f7043e91a6" title="returns an array where each representation is recorded only once, sorted by representation (stored on...">unique_representations()</a>, plus one more element with the total number of sketch elements (stored on host)  <a href="group__cudamapper.html#gae0141760d12af38d0c6daea48222f8b8">More...</a><br /></td></tr>
<tr class="separator:gae0141760d12af38d0c6daea48222f8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga146e2ebe0cdda62455209b3d6b6e9d7f"><td class="memItemLeft" align="right" valign="top">virtual read_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga146e2ebe0cdda62455209b3d6b6e9d7f">claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::number_of_reads</a> () const =0</td></tr>
<tr class="memdesc:ga146e2ebe0cdda62455209b3d6b6e9d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns number of reads in input data  <a href="group__cudamapper.html#ga146e2ebe0cdda62455209b3d6b6e9d7f">More...</a><br /></td></tr>
<tr class="separator:ga146e2ebe0cdda62455209b3d6b6e9d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga481097c50a2d528a444846175e6c75ce"><td class="memItemLeft" align="right" valign="top">virtual position_in_read_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga481097c50a2d528a444846175e6c75ce">claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::number_of_basepairs_in_longest_read</a> () const =0</td></tr>
<tr class="memdesc:ga481097c50a2d528a444846175e6c75ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns length of the longest read in this index  <a href="group__cudamapper.html#ga481097c50a2d528a444846175e6c75ce">More...</a><br /></td></tr>
<tr class="separator:ga481097c50a2d528a444846175e6c75ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf451b16843bfce7ccfc7c63934030e00"><td class="memItemLeft" align="right" valign="top">virtual read_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#gaf451b16843bfce7ccfc7c63934030e00">claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::first_read_id</a> () const =0</td></tr>
<tr class="memdesc:gaf451b16843bfce7ccfc7c63934030e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns stored value in first_read_id_ representing smallest read_id in index  <a href="group__cudamapper.html#gaf451b16843bfce7ccfc7c63934030e00">More...</a><br /></td></tr>
<tr class="separator:gaf451b16843bfce7ccfc7c63934030e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cab51c7a73bca18e51fdf87ce2f7f51"><td class="memItemLeft" align="right" valign="top">virtual std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga6cab51c7a73bca18e51fdf87ce2f7f51">claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::kmer_size</a> () const =0</td></tr>
<tr class="memdesc:ga6cab51c7a73bca18e51fdf87ce2f7f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns k-mer size  <a href="group__cudamapper.html#ga6cab51c7a73bca18e51fdf87ce2f7f51">More...</a><br /></td></tr>
<tr class="separator:ga6cab51c7a73bca18e51fdf87ce2f7f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf30edabb6c940af536bb8c858c800c96"><td class="memItemLeft" align="right" valign="top">virtual std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#gaf30edabb6c940af536bb8c858c800c96">claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::window_size</a> () const =0</td></tr>
<tr class="memdesc:gaf30edabb6c940af536bb8c858c800c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns window size  <a href="group__cudamapper.html#gaf30edabb6c940af536bb8c858c800c96">More...</a><br /></td></tr>
<tr class="separator:gaf30edabb6c940af536bb8c858c800c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga770b8f5d4161f2c075315523f7444478"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1IndexHostCopyBase.html">IndexHostCopyBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga770b8f5d4161f2c075315523f7444478">claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::create_cache</a> (const <a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Index.html">Index</a> &amp;index, const read_id_t <a class="el" href="group__cudamapper.html#gaf451b16843bfce7ccfc7c63934030e00">first_read_id</a>, const std::uint64_t <a class="el" href="group__cudamapper.html#ga6cab51c7a73bca18e51fdf87ce2f7f51">kmer_size</a>, const std::uint64_t <a class="el" href="group__cudamapper.html#gaf30edabb6c940af536bb8c858c800c96">window_size</a>, const cudaStream_t cuda_stream=0)</td></tr>
<tr class="memdesc:ga770b8f5d4161f2c075315523f7444478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="group__cudamapper.html#ga770b8f5d4161f2c075315523f7444478">More...</a><br /></td></tr>
<tr class="separator:ga770b8f5d4161f2c075315523f7444478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc80bdb4453ae4843b11a8c36cc590a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#gafc80bdb4453ae4843b11a8c36cc590a5">claraparabricks::genomeworks::cudamapper::details::overlapper::extend_overlap_by_sequence_similarity</a> (<a class="el" href="structclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Overlap.html">Overlap</a> &amp;overlap, gw_string_view_t &amp;query_sequence, gw_string_view_t &amp;target_sequence, std::int32_t extension, float required_similarity)</td></tr>
<tr class="memdesc:gafc80bdb4453ae4843b11a8c36cc590a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends a single overlap at its ends if the similarity of the query and target sequences is above a specified threshold.  <a href="group__cudamapper.html#gafc80bdb4453ae4843b11a8c36cc590a5">More...</a><br /></td></tr>
<tr class="separator:gafc80bdb4453ae4843b11a8c36cc590a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d08506eb6dc5176a89410f4dc0f148f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga4d08506eb6dc5176a89410f4dc0f148f">claraparabricks::genomeworks::cudamapper::details::overlapper::drop_overlaps_by_mask</a> (std::vector&lt; <a class="el" href="structclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Overlap.html">claraparabricks::genomeworks::cudamapper::Overlap</a> &gt; &amp;overlaps, const std::vector&lt; bool &gt; &amp;mask)</td></tr>
<tr class="memdesc:ga4d08506eb6dc5176a89410f4dc0f148f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes overlaps from a vector (modifying in place) based on a boolean mask.  <a href="group__cudamapper.html#ga4d08506eb6dc5176a89410f4dc0f148f">More...</a><br /></td></tr>
<tr class="separator:ga4d08506eb6dc5176a89410f4dc0f148f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6ae5c9f620e64267d7f8ccbd66e60ec"><td class="memItemLeft" align="right" valign="top"><a id="gaa6ae5c9f620e64267d7f8ccbd66e60ec"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#gaa6ae5c9f620e64267d7f8ccbd66e60ec">claraparabricks::genomeworks::cudamapper::Overlapper::~Overlapper</a> ()=default</td></tr>
<tr class="memdesc:gaa6ae5c9f620e64267d7f8ccbd66e60ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor for <a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Overlapper.html">Overlapper</a>. <br /></td></tr>
<tr class="separator:gaa6ae5c9f620e64267d7f8ccbd66e60ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72ada16ceb1580cf61b0ff5eb85d177a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga72ada16ceb1580cf61b0ff5eb85d177a">claraparabricks::genomeworks::cudamapper::Overlapper::get_overlaps</a> (std::vector&lt; <a class="el" href="structclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Overlap.html">Overlap</a> &gt; &amp;fused_overlaps, const <a class="el" href="classclaraparabricks_1_1genomeworks_1_1details_1_1buffer.html">device_buffer</a>&lt; <a class="el" href="structclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Anchor.html">Anchor</a> &gt; &amp;d_anchors, bool all_to_all, int64_t min_residues, int64_t min_overlap_len, int64_t min_bases_per_residue, float min_overlap_fraction)=0</td></tr>
<tr class="memdesc:ga72ada16ceb1580cf61b0ff5eb85d177a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns overlaps for a set of reads  <a href="group__cudamapper.html#ga72ada16ceb1580cf61b0ff5eb85d177a">More...</a><br /></td></tr>
<tr class="separator:ga72ada16ceb1580cf61b0ff5eb85d177a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6ef2c14780103891dbb3c0c6bb94376"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#gac6ef2c14780103891dbb3c0c6bb94376">claraparabricks::genomeworks::cudamapper::Overlapper::filter_overlaps</a> (std::vector&lt; <a class="el" href="structclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Overlap.html">Overlap</a> &gt; &amp;filtered_overlaps, const std::vector&lt; <a class="el" href="structclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Overlap.html">Overlap</a> &gt; &amp;overlaps, int64_t min_residues=20, int64_t min_overlap_len=50)</td></tr>
<tr class="memdesc:gac6ef2c14780103891dbb3c0c6bb94376"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes overlaps which are unlikely to be true overlaps  <a href="group__cudamapper.html#gac6ef2c14780103891dbb3c0c6bb94376">More...</a><br /></td></tr>
<tr class="separator:gac6ef2c14780103891dbb3c0c6bb94376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga500dcb7e3d7039724435ff0c9935a2b4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga500dcb7e3d7039724435ff0c9935a2b4">claraparabricks::genomeworks::cudamapper::Overlapper::post_process_overlaps</a> (std::vector&lt; <a class="el" href="structclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Overlap.html">Overlap</a> &gt; &amp;overlaps, bool drop_fused_overlaps=false)</td></tr>
<tr class="memdesc:ga500dcb7e3d7039724435ff0c9935a2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identified overlaps which can be combined into a larger overlap and add them to the input vector.  <a href="group__cudamapper.html#ga500dcb7e3d7039724435ff0c9935a2b4">More...</a><br /></td></tr>
<tr class="separator:ga500dcb7e3d7039724435ff0c9935a2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga630b7b0606473be8892473c47a948d9b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga630b7b0606473be8892473c47a948d9b">claraparabricks::genomeworks::cudamapper::Overlapper::rescue_overlap_ends</a> (std::vector&lt; <a class="el" href="structclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Overlap.html">Overlap</a> &gt; &amp;overlaps, const <a class="el" href="classclaraparabricks_1_1genomeworks_1_1io_1_1FastaParser.html">io::FastaParser</a> &amp;query_parser, const <a class="el" href="classclaraparabricks_1_1genomeworks_1_1io_1_1FastaParser.html">io::FastaParser</a> &amp;target_parser, std::int32_t extension, float required_similarity)</td></tr>
<tr class="memdesc:ga630b7b0606473be8892473c47a948d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector of overlaps, extend the start/end of the overlaps based on the sequence similarity of the query and target.  <a href="group__cudamapper.html#ga630b7b0606473be8892473c47a948d9b">More...</a><br /></td></tr>
<tr class="separator:ga630b7b0606473be8892473c47a948d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f892094edd0cd13458a9af45da42713"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Overlapper.html">Overlapper</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga1f892094edd0cd13458a9af45da42713">claraparabricks::genomeworks::cudamapper::Overlapper::create_overlapper</a> (<a class="el" href="classclaraparabricks_1_1genomeworks_1_1CudaMallocAllocator.html">DefaultDeviceAllocator</a> allocator, const cudaStream_t cuda_stream=0)</td></tr>
<tr class="memdesc:ga1f892094edd0cd13458a9af45da42713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Overlapper.html">Overlapper</a> object.  <a href="group__cudamapper.html#ga1f892094edd0cd13458a9af45da42713">More...</a><br /></td></tr>
<tr class="separator:ga1f892094edd0cd13458a9af45da42713"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Base docs for the cudamapper package (tbd) </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gadf16c3675fb7b4d2ea891efaed8d4d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf16c3675fb7b4d2ea891efaed8d4d4b">&#9670;&nbsp;</a></span>copy_index_to_device()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Index.html">Index</a>&gt; claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::copy_index_to_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclaraparabricks_1_1genomeworks_1_1CudaMallocAllocator.html">DefaultDeviceAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cudaStream_t&#160;</td>
          <td class="paramname"><em>cuda_stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy cached index vectors from the host and create an object of <a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Index.html" title="Index - manages mapping of (k,w)-kmer-representation and all its occurences.">Index</a> on GPU </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>asynchronous device allocator used for temporary buffer allocations </td></tr>
    <tr><td class="paramname">cuda_stream</td><td>H2D copy is done on this stream. Device arrays are also associated with this stream and will not be freed at least until all work issued on this stream before calling their destructor is done </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to <a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Index.html" title="Index - manages mapping of (k,w)-kmer-representation and all its occurences.">genomeworks::cudamapper::Index</a> </dd></dl>

</div>
</div>
<a id="ga770b8f5d4161f2c075315523f7444478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga770b8f5d4161f2c075315523f7444478">&#9670;&nbsp;</a></span>create_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt;<a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1IndexHostCopyBase.html">IndexHostCopyBase</a>&gt; claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::create_cache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Index.html">Index</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const read_id_t&#160;</td>
          <td class="paramname"><em>first_read_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::uint64_t&#160;</td>
          <td class="paramname"><em>kmer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::uint64_t&#160;</td>
          <td class="paramname"><em>window_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cudaStream_t&#160;</td>
          <td class="paramname"><em>cuda_stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>creates a copy of input processed index on the host </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>- pointer to computed index parameters (vectors of sketch elements) on GPU </td></tr>
    <tr><td class="paramname">first_read_id</td><td>- representing smallest read_id in index </td></tr>
    <tr><td class="paramname">kmer_size</td><td>- number of basepairs in a k-mer </td></tr>
    <tr><td class="paramname">window_size</td><td>the number of adjacent k-mers in a window, adjacent = shifted by one basepair </td></tr>
    <tr><td class="paramname">cuda_stream</td><td>D2H copy is done on this stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- an instance of <a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1IndexHostCopyBase.html">IndexHostCopyBase</a> </dd></dl>

</div>
</div>
<a id="ga94383d9d95a69977f72ed3b05162f874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94383d9d95a69977f72ed3b05162f874">&#9670;&nbsp;</a></span>create_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt;<a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Index.html">Index</a>&gt; claraparabricks::genomeworks::cudamapper::Index::create_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclaraparabricks_1_1genomeworks_1_1CudaMallocAllocator.html">DefaultDeviceAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclaraparabricks_1_1genomeworks_1_1io_1_1FastaParser.html">io::FastaParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const read_id_t&#160;</td>
          <td class="paramname"><em>first_read_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const read_id_t&#160;</td>
          <td class="paramname"><em>past_the_last_read_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::uint64_t&#160;</td>
          <td class="paramname"><em>kmer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::uint64_t&#160;</td>
          <td class="paramname"><em>window_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>hash_representations</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>filtering_parameter</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cudaStream_t&#160;</td>
          <td class="paramname"><em>cuda_stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>generates a mapping of (k,w)-kmer-representation to all of its occurrences for one or more sequences </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The device memory allocator to use for temporary buffer allocations </td></tr>
    <tr><td class="paramname">parser</td><td>parser for the whole input file (part that goes into this index is determined by first_read_id and past_the_last_read_id) </td></tr>
    <tr><td class="paramname">first_read_id</td><td>read_id of the first read to the included in this index </td></tr>
    <tr><td class="paramname">past_the_last_read_id</td><td>read_id+1 of the last read to be included in this index </td></tr>
    <tr><td class="paramname">kmer_size</td><td>k - the kmer length </td></tr>
    <tr><td class="paramname">window_size</td><td>w - the length of the sliding window used to find sketch elements (i.e. the number of adjacent kmers in a window, adjacent = shifted by one basepair) </td></tr>
    <tr><td class="paramname">hash_representations</td><td>if true, hash kmer representations </td></tr>
    <tr><td class="paramname">filtering_parameter</td><td>filter out all representations for which number_of_sketch_elements_with_that_representation/total_skech_elements &gt;= filtering_parameter, filtering_parameter == 1.0 disables filtering </td></tr>
    <tr><td class="paramname">cuda_stream</td><td>CUDA stream on which the work is to be done. Device arrays are also associated with this stream and will not be freed at least until all work issued on this stream before calling their destructor is done </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>instance of <a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Index.html" title="Index - manages mapping of (k,w)-kmer-representation and all its occurences.">Index</a> </dd></dl>

</div>
</div>
<a id="ga1f892094edd0cd13458a9af45da42713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f892094edd0cd13458a9af45da42713">&#9670;&nbsp;</a></span>create_overlapper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt;<a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Overlapper.html">Overlapper</a>&gt; claraparabricks::genomeworks::cudamapper::Overlapper::create_overlapper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclaraparabricks_1_1genomeworks_1_1CudaMallocAllocator.html">DefaultDeviceAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cudaStream_t&#160;</td>
          <td class="paramname"><em>cuda_stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Overlapper.html">Overlapper</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The device memory allocator to use for buffer allocations </td></tr>
    <tr><td class="paramname">cuda_stream</td><td>CUDA stream on which the work is to be done. Device arrays are also associated with this stream and will not be freed at least until all work issued on this stream before calling their destructor is done </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance of <a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Overlapper.html">Overlapper</a> </dd></dl>

</div>
</div>
<a id="gaf331310d832baa8f1d98c3e0b38f55e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf331310d832baa8f1d98c3e0b38f55e1">&#9670;&nbsp;</a></span>directions_of_reads() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classclaraparabricks_1_1genomeworks_1_1details_1_1buffer.html">device_buffer</a>&lt;<a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1SketchElement.html#afa33c55e7eb7a95cc5d9b7a18f546274">SketchElement::DirectionOfRepresentation</a>&gt;&amp; claraparabricks::genomeworks::cudamapper::Index::directions_of_reads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an array of directions in which sketch elements were read </p>
<dl class="section return"><dt>Returns</dt><dd>an array of directions in which sketch elements were read </dd></dl>

</div>
</div>
<a id="gab9e6aa4523e65918eb9b3b468b80335e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9e6aa4523e65918eb9b3b468b80335e">&#9670;&nbsp;</a></span>directions_of_reads() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::vector&lt;<a class="el" href="classclaraparabricks_1_1genomeworks_1_1cudamapper_1_1SketchElement.html#afa33c55e7eb7a95cc5d9b7a18f546274">SketchElement::DirectionOfRepresentation</a>&gt;&amp; claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::directions_of_reads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an array of directions in which sketch elements were read (stored on host) </p>
<dl class="section return"><dt>Returns</dt><dd>an array of directions in which sketch elements were read </dd></dl>

</div>
</div>
<a id="ga4d08506eb6dc5176a89410f4dc0f148f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d08506eb6dc5176a89410f4dc0f148f">&#9670;&nbsp;</a></span>drop_overlaps_by_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void claraparabricks::genomeworks::cudamapper::details::overlapper::drop_overlaps_by_mask </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Overlap.html">claraparabricks::genomeworks::cudamapper::Overlap</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>overlaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes overlaps from a vector (modifying in place) based on a boolean mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overlaps</td><td>A vector (reference) of overlaps </td></tr>
    <tr><td class="paramname">mask</td><td>A vector of bools the same length as overlaps. If an index is true, the overlap at the corresponding index in overlaps is removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafc80bdb4453ae4843b11a8c36cc590a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc80bdb4453ae4843b11a8c36cc590a5">&#9670;&nbsp;</a></span>extend_overlap_by_sequence_similarity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void claraparabricks::genomeworks::cudamapper::details::overlapper::extend_overlap_by_sequence_similarity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Overlap.html">Overlap</a> &amp;&#160;</td>
          <td class="paramname"><em>overlap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gw_string_view_t &amp;&#160;</td>
          <td class="paramname"><em>query_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gw_string_view_t &amp;&#160;</td>
          <td class="paramname"><em>target_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>required_similarity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extends a single overlap at its ends if the similarity of the query and target sequences is above a specified threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overlap</td><td>An <a class="el" href="structclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Overlap.html">Overlap</a> which is modified in place. Any of the query_start_position_in_read, query_end_position_in_read, target_start_position_in_read, and target_end_position_in_read fields may be modified. </td></tr>
    <tr><td class="paramname">query_sequence</td><td>A std::string_view of the query read sequence. </td></tr>
    <tr><td class="paramname">target_sequence</td><td>A std::string_view of the target read sequence. </td></tr>
    <tr><td class="paramname">extension</td><td>The number of bases to extend at the head and tail of the overlap. If the head or tail is shorter than extension, the function only tries to extend to the end of the read. </td></tr>
    <tr><td class="paramname">required_similarity</td><td>The minimum similarity to require to extend an overlap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac6ef2c14780103891dbb3c0c6bb94376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6ef2c14780103891dbb3c0c6bb94376">&#9670;&nbsp;</a></span>filter_overlaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void claraparabricks::genomeworks::cudamapper::Overlapper::filter_overlaps </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Overlap.html">Overlap</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>filtered_overlaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Overlap.html">Overlap</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>overlaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_residues</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_overlap_len</em> = <code>50</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>removes overlaps which are unlikely to be true overlaps </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filtered_overlaps</td><td>Output vector in which to place filtered overlaps </td></tr>
    <tr><td class="paramname">overlaps</td><td>vector of <a class="el" href="structclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Overlap.html">Overlap</a> objects to be filtered </td></tr>
    <tr><td class="paramname">min_residues</td><td>smallest number of residues (anchors) for an overlap to be accepted </td></tr>
    <tr><td class="paramname">min_overlap_len</td><td>the smallest overlap distance which is accepted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf6e120ef97a1c4af963008b5fcc82403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6e120ef97a1c4af963008b5fcc82403">&#9670;&nbsp;</a></span>first_occurrence_of_representations() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classclaraparabricks_1_1genomeworks_1_1details_1_1buffer.html">device_buffer</a>&lt;std::uint32_t&gt;&amp; claraparabricks::genomeworks::cudamapper::Index::first_occurrence_of_representations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns first occurrence of corresponding representation from <a class="el" href="group__cudamapper.html#ga9012be3598ec4d979289fa5954c1bb7d" title="returns an array where each representation is recorder only once, sorted by representation">unique_representations()</a> in data arrays </p>
<dl class="section return"><dt>Returns</dt><dd>first occurrence of corresponding representation from <a class="el" href="group__cudamapper.html#ga9012be3598ec4d979289fa5954c1bb7d" title="returns an array where each representation is recorder only once, sorted by representation">unique_representations()</a> in data arrays </dd></dl>

</div>
</div>
<a id="gae0141760d12af38d0c6daea48222f8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0141760d12af38d0c6daea48222f8b8">&#9670;&nbsp;</a></span>first_occurrence_of_representations() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::vector&lt;std::uint32_t&gt;&amp; claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::first_occurrence_of_representations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns first occurrence of corresponding representation from <a class="el" href="group__cudamapper.html#ga30f0292e61c1f6d1062c73f7043e91a6" title="returns an array where each representation is recorded only once, sorted by representation (stored on...">unique_representations()</a>, plus one more element with the total number of sketch elements (stored on host) </p>
<dl class="section return"><dt>Returns</dt><dd>first occurrence of corresponding representation from <a class="el" href="group__cudamapper.html#ga30f0292e61c1f6d1062c73f7043e91a6" title="returns an array where each representation is recorded only once, sorted by representation (stored on...">unique_representations()</a>, plus one more element with the total number of sketch elements </dd></dl>

</div>
</div>
<a id="gaf451b16843bfce7ccfc7c63934030e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf451b16843bfce7ccfc7c63934030e00">&#9670;&nbsp;</a></span>first_read_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual read_id_t claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::first_read_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns stored value in first_read_id_ representing smallest read_id in index </p>
<dl class="section return"><dt>Returns</dt><dd>first_read_id_ </dd></dl>

</div>
</div>
<a id="ga72ada16ceb1580cf61b0ff5eb85d177a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72ada16ceb1580cf61b0ff5eb85d177a">&#9670;&nbsp;</a></span>get_overlaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void claraparabricks::genomeworks::cudamapper::Overlapper::get_overlaps </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Overlap.html">Overlap</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fused_overlaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclaraparabricks_1_1genomeworks_1_1details_1_1buffer.html">device_buffer</a>&lt; <a class="el" href="structclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Anchor.html">Anchor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_anchors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all_to_all</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_residues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_overlap_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_bases_per_residue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_overlap_fraction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns overlaps for a set of reads </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fused_overlaps</td><td>Output vector into which generated overlaps will be placed </td></tr>
    <tr><td class="paramname">d_anchors</td><td>vector of anchors sorted by query_read_id -&gt; target_read_id -&gt; query_position_in_read -&gt; target_position_in_read (meaning sorted by query_read_id, then within a group of anchors with the same value of query_read_id sorted by target_read_id and so on) </td></tr>
    <tr><td class="paramname">all_to_all</td><td>True if the target and query indexes are of the same FASTx file. If true, ignore self-self mappings when retrieving overlaps. </td></tr>
    <tr><td class="paramname">min_residues</td><td>smallest number of residues (anchors) for an overlap to be accepted </td></tr>
    <tr><td class="paramname">min_overlap_len</td><td>the smallest overlap distance which is accepted </td></tr>
    <tr><td class="paramname">min_bases_per_residue</td><td>the minimum number of nucleotides per residue (e.g minimizer) in an overlap </td></tr>
    <tr><td class="paramname">min_overlap_fraction</td><td>the minimum ratio between the shortest and longest of the target and query components of an overlap. e.g if Query range is (150,1000) and target range is (1000,2000) then overlap fraction is 0.85 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6cab51c7a73bca18e51fdf87ce2f7f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cab51c7a73bca18e51fdf87ce2f7f51">&#9670;&nbsp;</a></span>kmer_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::uint64_t claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::kmer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns k-mer size </p>
<dl class="section return"><dt>Returns</dt><dd>kmer_size_ </dd></dl>

</div>
</div>
<a id="ga7f69e6fa88662eff1ab7c87edfc7ef32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f69e6fa88662eff1ab7c87edfc7ef32">&#9670;&nbsp;</a></span>largest_read_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual read_id_t claraparabricks::genomeworks::cudamapper::Index::largest_read_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns largest read_id in index </p>
<dl class="section return"><dt>Returns</dt><dd>largest read_id in index (0 if empty index) </dd></dl>

</div>
</div>
<a id="ga98eb05b517a7c7a9fe85164d265841ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98eb05b517a7c7a9fe85164d265841ed">&#9670;&nbsp;</a></span>maximum_kmer_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t claraparabricks::genomeworks::cudamapper::Index::maximum_kmer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum kmer length allowable. </p>
<dl class="section return"><dt>Returns</dt><dd>Return the maximum kmer length allowable </dd></dl>

</div>
</div>
<a id="gaca45bc654ce38bc06c960a432a641916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca45bc654ce38bc06c960a432a641916">&#9670;&nbsp;</a></span>number_of_basepairs_in_longest_read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual position_in_read_t claraparabricks::genomeworks::cudamapper::Index::number_of_basepairs_in_longest_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns length of the longest read in this index </p>
<dl class="section return"><dt>Returns</dt><dd>length of the longest read in this index </dd></dl>

</div>
</div>
<a id="ga481097c50a2d528a444846175e6c75ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga481097c50a2d528a444846175e6c75ce">&#9670;&nbsp;</a></span>number_of_basepairs_in_longest_read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual position_in_read_t claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::number_of_basepairs_in_longest_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns length of the longest read in this index </p>
<dl class="section return"><dt>Returns</dt><dd>length of the longest read in this index </dd></dl>

</div>
</div>
<a id="gab769e543662cab81e53e8ca7e1ab56f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab769e543662cab81e53e8ca7e1ab56f9">&#9670;&nbsp;</a></span>number_of_reads() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual read_id_t claraparabricks::genomeworks::cudamapper::Index::number_of_reads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns number of reads in input data </p>
<dl class="section return"><dt>Returns</dt><dd>number of reads in input data </dd></dl>

</div>
</div>
<a id="ga146e2ebe0cdda62455209b3d6b6e9d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga146e2ebe0cdda62455209b3d6b6e9d7f">&#9670;&nbsp;</a></span>number_of_reads() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual read_id_t claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::number_of_reads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns number of reads in input data </p>
<dl class="section return"><dt>Returns</dt><dd>number of reads in input data </dd></dl>

</div>
</div>
<a id="ga29cef625e1b5bfcac9937dd06a3d5452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29cef625e1b5bfcac9937dd06a3d5452">&#9670;&nbsp;</a></span>positions_in_reads() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classclaraparabricks_1_1genomeworks_1_1details_1_1buffer.html">device_buffer</a>&lt;position_in_read_t&gt;&amp; claraparabricks::genomeworks::cudamapper::Index::positions_in_reads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an array of starting positions of sketch elements in their reads </p>
<dl class="section return"><dt>Returns</dt><dd>an array of starting positions of sketch elements in their reads </dd></dl>

</div>
</div>
<a id="ga9b833e24986c9d3371ab4e5028e7330c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b833e24986c9d3371ab4e5028e7330c">&#9670;&nbsp;</a></span>positions_in_reads() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::vector&lt;position_in_read_t&gt;&amp; claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::positions_in_reads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an array of starting positions of sketch elements in their reads (stored on host) </p>
<dl class="section return"><dt>Returns</dt><dd>an array of starting positions of sketch elements in their reads </dd></dl>

</div>
</div>
<a id="ga500dcb7e3d7039724435ff0c9935a2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga500dcb7e3d7039724435ff0c9935a2b4">&#9670;&nbsp;</a></span>post_process_overlaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void claraparabricks::genomeworks::cudamapper::Overlapper::post_process_overlaps </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Overlap.html">Overlap</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>overlaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>drop_fused_overlaps</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identified overlaps which can be combined into a larger overlap and add them to the input vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overlaps</td><td>reference to vector of Overlaps. New overlaps (result of fusing) are added to this vector </td></tr>
    <tr><td class="paramname">drop_fused_overlaps</td><td>If true, remove overlaps that are fused into larger overlaps in output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8c953d45217acb55ef8ad6f09450d1b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c953d45217acb55ef8ad6f09450d1b8">&#9670;&nbsp;</a></span>read_ids() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classclaraparabricks_1_1genomeworks_1_1details_1_1buffer.html">device_buffer</a>&lt;read_id_t&gt;&amp; claraparabricks::genomeworks::cudamapper::Index::read_ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an array of reads ids for sketch elements </p>
<dl class="section return"><dt>Returns</dt><dd>an array of reads ids for sketch elements </dd></dl>

</div>
</div>
<a id="ga873f6ab8eb381b6231463aa2d3f0e753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga873f6ab8eb381b6231463aa2d3f0e753">&#9670;&nbsp;</a></span>read_ids() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::vector&lt;read_id_t&gt;&amp; claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::read_ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an array of reads ids for sketch elements (stored on host) </p>
<dl class="section return"><dt>Returns</dt><dd>an array of reads ids for sketch elements </dd></dl>

</div>
</div>
<a id="gaed943d2e0a9c706ed46a2bf1a4899c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed943d2e0a9c706ed46a2bf1a4899c4d">&#9670;&nbsp;</a></span>representations() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classclaraparabricks_1_1genomeworks_1_1details_1_1buffer.html">device_buffer</a>&lt;representation_t&gt;&amp; claraparabricks::genomeworks::cudamapper::Index::representations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an array of representations of sketch elements </p>
<dl class="section return"><dt>Returns</dt><dd>an array of representations of sketch elements </dd></dl>

</div>
</div>
<a id="ga23dde7ca05b079b1d5b6f3cbae5462a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23dde7ca05b079b1d5b6f3cbae5462a4">&#9670;&nbsp;</a></span>representations() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::vector&lt;representation_t&gt;&amp; claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::representations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an array of representations of sketch elements (stored on host) </p>
<dl class="section return"><dt>Returns</dt><dd>an array of representations of sketch elements </dd></dl>

</div>
</div>
<a id="ga630b7b0606473be8892473c47a948d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga630b7b0606473be8892473c47a948d9b">&#9670;&nbsp;</a></span>rescue_overlap_ends()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void claraparabricks::genomeworks::cudamapper::Overlapper::rescue_overlap_ends </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structclaraparabricks_1_1genomeworks_1_1cudamapper_1_1Overlap.html">Overlap</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>overlaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclaraparabricks_1_1genomeworks_1_1io_1_1FastaParser.html">io::FastaParser</a> &amp;&#160;</td>
          <td class="paramname"><em>query_parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclaraparabricks_1_1genomeworks_1_1io_1_1FastaParser.html">io::FastaParser</a> &amp;&#160;</td>
          <td class="paramname"><em>target_parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>required_similarity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a vector of overlaps, extend the start/end of the overlaps based on the sequence similarity of the query and target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overlaps</td><td>A vector of overlaps. This is modified in-place; query_start_position_in_read_, query_end_position_in_read_, target_start_position_in_read_ and target_end_position_in_read_ may be modified. </td></tr>
    <tr><td class="paramname">query_parser</td><td>A FastaParser for query sequences. </td></tr>
    <tr><td class="paramname">target_parser</td><td>A FastaParser for target sequences. </td></tr>
    <tr><td class="paramname">extension</td><td>The number of basepairs to extend and overlap. </td></tr>
    <tr><td class="paramname">required_similarity</td><td>The minimum similarity required to extend an overlap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf19ac4dc5ee6809368955500e4023e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf19ac4dc5ee6809368955500e4023e6d">&#9670;&nbsp;</a></span>smallest_read_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual read_id_t claraparabricks::genomeworks::cudamapper::Index::smallest_read_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns smallest read_id in index </p>
<dl class="section return"><dt>Returns</dt><dd>smallest read_id in index (0 if empty index) </dd></dl>

</div>
</div>
<a id="ga9012be3598ec4d979289fa5954c1bb7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9012be3598ec4d979289fa5954c1bb7d">&#9670;&nbsp;</a></span>unique_representations() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classclaraparabricks_1_1genomeworks_1_1details_1_1buffer.html">device_buffer</a>&lt;representation_t&gt;&amp; claraparabricks::genomeworks::cudamapper::Index::unique_representations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an array where each representation is recorder only once, sorted by representation </p>
<dl class="section return"><dt>Returns</dt><dd>an array where each representation is recorder only once, sorted by representation </dd></dl>

</div>
</div>
<a id="ga30f0292e61c1f6d1062c73f7043e91a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30f0292e61c1f6d1062c73f7043e91a6">&#9670;&nbsp;</a></span>unique_representations() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::vector&lt;representation_t&gt;&amp; claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::unique_representations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an array where each representation is recorded only once, sorted by representation (stored on host) </p>
<dl class="section return"><dt>Returns</dt><dd>an array where each representation is recorded only once, sorted by representation </dd></dl>

</div>
</div>
<a id="gaf30edabb6c940af536bb8c858c800c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf30edabb6c940af536bb8c858c800c96">&#9670;&nbsp;</a></span>window_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::uint64_t claraparabricks::genomeworks::cudamapper::IndexHostCopyBase::window_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns window size </p>
<dl class="section return"><dt>Returns</dt><dd>window_size_ </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
