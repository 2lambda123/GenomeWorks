<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ClaraGenomicsAnalysis: CUDA mapper package</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ClaraGenomicsAnalysis
   &#160;<span id="projectnumber">0.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CUDA mapper package</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base docs for the cudamapper package (tbd)  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclaragenomics_1_1cudamapper_1_1Index.html">claragenomics::cudamapper::Index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclaragenomics_1_1cudamapper_1_1Index.html" title="Index - manages mapping of (k,w)-kmer-representation and all its occurences.">Index</a> - manages mapping of (k,w)-kmer-representation and all its occurences.  <a href="classclaragenomics_1_1cudamapper_1_1Index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclaragenomics_1_1cudamapper_1_1IndexHostCopyBase.html">claragenomics::cudamapper::IndexHostCopyBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclaragenomics_1_1cudamapper_1_1Matcher.html">claragenomics::cudamapper::Matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclaragenomics_1_1cudamapper_1_1Matcher.html" title="Matcher - base matcher.">Matcher</a> - base matcher.  <a href="classclaragenomics_1_1cudamapper_1_1Matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclaragenomics_1_1cudamapper_1_1Overlapper.html">claragenomics::cudamapper::Overlapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclaragenomics_1_1cudamapper_1_1SketchElement.html">claragenomics::cudamapper::SketchElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclaragenomics_1_1cudamapper_1_1SketchElement.html" title="SketchElement - Contains integer representation, position, direction and read id of a kmer.">SketchElement</a> - Contains integer representation, position, direction and read id of a kmer.  <a href="classclaragenomics_1_1cudamapper_1_1SketchElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafcaccc9f9526d9c66280eca17ff3a4ac"><td class="memItemLeft" align="right" valign="top"><a id="gafcaccc9f9526d9c66280eca17ff3a4ac"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#gafcaccc9f9526d9c66280eca17ff3a4ac">claragenomics::cudamapper::Index::~Index</a> ()=default</td></tr>
<tr class="memdesc:gafcaccc9f9526d9c66280eca17ff3a4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor. <br /></td></tr>
<tr class="separator:gafcaccc9f9526d9c66280eca17ff3a4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c15374cb6642179acb57ecc19ecbbd5"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classclaragenomics_1_1buffer.html">device_buffer</a>&lt; representation_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga4c15374cb6642179acb57ecc19ecbbd5">claragenomics::cudamapper::Index::representations</a> () const =0</td></tr>
<tr class="memdesc:ga4c15374cb6642179acb57ecc19ecbbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an array of representations of sketch elements  <a href="group__cudamapper.html#ga4c15374cb6642179acb57ecc19ecbbd5">More...</a><br /></td></tr>
<tr class="separator:ga4c15374cb6642179acb57ecc19ecbbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga104c899ad0522ea91786994b63470e8f"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classclaragenomics_1_1buffer.html">device_buffer</a>&lt; read_id_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga104c899ad0522ea91786994b63470e8f">claragenomics::cudamapper::Index::read_ids</a> () const =0</td></tr>
<tr class="memdesc:ga104c899ad0522ea91786994b63470e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an array of reads ids for sketch elements  <a href="group__cudamapper.html#ga104c899ad0522ea91786994b63470e8f">More...</a><br /></td></tr>
<tr class="separator:ga104c899ad0522ea91786994b63470e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ea546f53cd32cf6ebf1ce02fbaf8fce"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classclaragenomics_1_1buffer.html">device_buffer</a>&lt; position_in_read_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga6ea546f53cd32cf6ebf1ce02fbaf8fce">claragenomics::cudamapper::Index::positions_in_reads</a> () const =0</td></tr>
<tr class="memdesc:ga6ea546f53cd32cf6ebf1ce02fbaf8fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an array of starting positions of sketch elements in their reads  <a href="group__cudamapper.html#ga6ea546f53cd32cf6ebf1ce02fbaf8fce">More...</a><br /></td></tr>
<tr class="separator:ga6ea546f53cd32cf6ebf1ce02fbaf8fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65817f40ba793c63c356fb97caff9522"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classclaragenomics_1_1buffer.html">device_buffer</a>&lt; <a class="el" href="classclaragenomics_1_1cudamapper_1_1SketchElement.html#a83beb5c091c4b0bfec99c04b6bc8777a">SketchElement::DirectionOfRepresentation</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga65817f40ba793c63c356fb97caff9522">claragenomics::cudamapper::Index::directions_of_reads</a> () const =0</td></tr>
<tr class="memdesc:ga65817f40ba793c63c356fb97caff9522"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an array of directions in which sketch elements were read  <a href="group__cudamapper.html#ga65817f40ba793c63c356fb97caff9522">More...</a><br /></td></tr>
<tr class="separator:ga65817f40ba793c63c356fb97caff9522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c0fe1c2988d7c9f0c652909b0f0f6e7"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classclaragenomics_1_1buffer.html">device_buffer</a>&lt; representation_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga9c0fe1c2988d7c9f0c652909b0f0f6e7">claragenomics::cudamapper::Index::unique_representations</a> () const =0</td></tr>
<tr class="memdesc:ga9c0fe1c2988d7c9f0c652909b0f0f6e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an array where each representation is recorder only once, sorted by representation  <a href="group__cudamapper.html#ga9c0fe1c2988d7c9f0c652909b0f0f6e7">More...</a><br /></td></tr>
<tr class="separator:ga9c0fe1c2988d7c9f0c652909b0f0f6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23503e693b8c804a14e6f773a2a8f6e4"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classclaragenomics_1_1buffer.html">device_buffer</a>&lt; std::uint32_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga23503e693b8c804a14e6f773a2a8f6e4">claragenomics::cudamapper::Index::first_occurrence_of_representations</a> () const =0</td></tr>
<tr class="memdesc:ga23503e693b8c804a14e6f773a2a8f6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns first occurrence of corresponding representation from <a class="el" href="group__cudamapper.html#ga9c0fe1c2988d7c9f0c652909b0f0f6e7" title="returns an array where each representation is recorder only once, sorted by representation">unique_representations()</a> in data arrays  <a href="group__cudamapper.html#ga23503e693b8c804a14e6f773a2a8f6e4">More...</a><br /></td></tr>
<tr class="separator:ga23503e693b8c804a14e6f773a2a8f6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23208afd4c7438a24a45cdb9cdf24dee"><td class="memItemLeft" align="right" valign="top">virtual read_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga23208afd4c7438a24a45cdb9cdf24dee">claragenomics::cudamapper::Index::number_of_reads</a> () const =0</td></tr>
<tr class="memdesc:ga23208afd4c7438a24a45cdb9cdf24dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns number of reads in input data  <a href="group__cudamapper.html#ga23208afd4c7438a24a45cdb9cdf24dee">More...</a><br /></td></tr>
<tr class="separator:ga23208afd4c7438a24a45cdb9cdf24dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e47e8d4eea8b8c48cf7501e1f217dd3"><td class="memItemLeft" align="right" valign="top">virtual read_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga0e47e8d4eea8b8c48cf7501e1f217dd3">claragenomics::cudamapper::Index::smallest_read_id</a> () const =0</td></tr>
<tr class="memdesc:ga0e47e8d4eea8b8c48cf7501e1f217dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns smallest read_id in index  <a href="group__cudamapper.html#ga0e47e8d4eea8b8c48cf7501e1f217dd3">More...</a><br /></td></tr>
<tr class="separator:ga0e47e8d4eea8b8c48cf7501e1f217dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4806eed2d87f879fe2ff10e1bf1cc76"><td class="memItemLeft" align="right" valign="top">virtual read_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#gad4806eed2d87f879fe2ff10e1bf1cc76">claragenomics::cudamapper::Index::largest_read_id</a> () const =0</td></tr>
<tr class="memdesc:gad4806eed2d87f879fe2ff10e1bf1cc76"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns largest read_id in index  <a href="group__cudamapper.html#gad4806eed2d87f879fe2ff10e1bf1cc76">More...</a><br /></td></tr>
<tr class="separator:gad4806eed2d87f879fe2ff10e1bf1cc76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d82b107e7846ef2714b728af83b8a0a"><td class="memItemLeft" align="right" valign="top">virtual position_in_read_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga8d82b107e7846ef2714b728af83b8a0a">claragenomics::cudamapper::Index::number_of_basepairs_in_longest_read</a> () const =0</td></tr>
<tr class="memdesc:ga8d82b107e7846ef2714b728af83b8a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns length of the longest read in this index  <a href="group__cudamapper.html#ga8d82b107e7846ef2714b728af83b8a0a">More...</a><br /></td></tr>
<tr class="separator:ga8d82b107e7846ef2714b728af83b8a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9247d4b637615bf5912acc57b27b919"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#gaf9247d4b637615bf5912acc57b27b919">claragenomics::cudamapper::Index::maximum_kmer_size</a> ()</td></tr>
<tr class="memdesc:gaf9247d4b637615bf5912acc57b27b919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum kmer length allowable.  <a href="group__cudamapper.html#gaf9247d4b637615bf5912acc57b27b919">More...</a><br /></td></tr>
<tr class="separator:gaf9247d4b637615bf5912acc57b27b919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4bfb3b8417c5bfd89ae66c6d2a041ba"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classclaragenomics_1_1cudamapper_1_1Index.html">Index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#gab4bfb3b8417c5bfd89ae66c6d2a041ba">claragenomics::cudamapper::Index::create_index</a> (<a class="el" href="classclaragenomics_1_1CudaMallocAllocator.html">DefaultDeviceAllocator</a> allocator, const <a class="el" href="classclaragenomics_1_1io_1_1FastaParser.html">io::FastaParser</a> &amp;parser, const read_id_t first_read_id, const read_id_t past_the_last_read_id, const std::uint64_t kmer_size, const std::uint64_t window_size, const bool hash_representations=true, const double filtering_parameter=1.0, const cudaStream_t cuda_stream=0)</td></tr>
<tr class="memdesc:gab4bfb3b8417c5bfd89ae66c6d2a041ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">generates a mapping of (k,w)-kmer-representation to all of its occurrences for one or more sequences  <a href="group__cudamapper.html#gab4bfb3b8417c5bfd89ae66c6d2a041ba">More...</a><br /></td></tr>
<tr class="separator:gab4bfb3b8417c5bfd89ae66c6d2a041ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4ae4c5e439c3a607a07b5fa3e5ee7a7"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classclaragenomics_1_1cudamapper_1_1Index.html">Index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#gae4ae4c5e439c3a607a07b5fa3e5ee7a7">claragenomics::cudamapper::IndexHostCopyBase::copy_index_to_device</a> (<a class="el" href="classclaragenomics_1_1CudaMallocAllocator.html">DefaultDeviceAllocator</a> allocator, const cudaStream_t cuda_stream=0) const =0</td></tr>
<tr class="memdesc:gae4ae4c5e439c3a607a07b5fa3e5ee7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy cached index vectors from the host and create an object of <a class="el" href="classclaragenomics_1_1cudamapper_1_1Index.html" title="Index - manages mapping of (k,w)-kmer-representation and all its occurences.">Index</a> on GPU  <a href="group__cudamapper.html#gae4ae4c5e439c3a607a07b5fa3e5ee7a7">More...</a><br /></td></tr>
<tr class="separator:gae4ae4c5e439c3a607a07b5fa3e5ee7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50737c42c9a7b0ce525875f454172d55"><td class="memItemLeft" align="right" valign="top"><a id="ga50737c42c9a7b0ce525875f454172d55"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga50737c42c9a7b0ce525875f454172d55">claragenomics::cudamapper::IndexHostCopyBase::~IndexHostCopyBase</a> ()=default</td></tr>
<tr class="memdesc:ga50737c42c9a7b0ce525875f454172d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual destructor <br /></td></tr>
<tr class="separator:ga50737c42c9a7b0ce525875f454172d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7adadddfc7a5c1c6e45434145e7266d2"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; representation_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga7adadddfc7a5c1c6e45434145e7266d2">claragenomics::cudamapper::IndexHostCopyBase::representations</a> () const =0</td></tr>
<tr class="memdesc:ga7adadddfc7a5c1c6e45434145e7266d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an array of representations of sketch elements (stored on host)  <a href="group__cudamapper.html#ga7adadddfc7a5c1c6e45434145e7266d2">More...</a><br /></td></tr>
<tr class="separator:ga7adadddfc7a5c1c6e45434145e7266d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9be5f568a1a29a571e4bf235673fa32c"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; read_id_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga9be5f568a1a29a571e4bf235673fa32c">claragenomics::cudamapper::IndexHostCopyBase::read_ids</a> () const =0</td></tr>
<tr class="memdesc:ga9be5f568a1a29a571e4bf235673fa32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an array of reads ids for sketch elements (stored on host)  <a href="group__cudamapper.html#ga9be5f568a1a29a571e4bf235673fa32c">More...</a><br /></td></tr>
<tr class="separator:ga9be5f568a1a29a571e4bf235673fa32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e305008b43cecb83f9996d53a7c8441"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; position_in_read_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga6e305008b43cecb83f9996d53a7c8441">claragenomics::cudamapper::IndexHostCopyBase::positions_in_reads</a> () const =0</td></tr>
<tr class="memdesc:ga6e305008b43cecb83f9996d53a7c8441"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an array of starting positions of sketch elements in their reads (stored on host)  <a href="group__cudamapper.html#ga6e305008b43cecb83f9996d53a7c8441">More...</a><br /></td></tr>
<tr class="separator:ga6e305008b43cecb83f9996d53a7c8441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24fd5715d983da7866919980f7091fdb"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; <a class="el" href="classclaragenomics_1_1cudamapper_1_1SketchElement.html#a83beb5c091c4b0bfec99c04b6bc8777a">SketchElement::DirectionOfRepresentation</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga24fd5715d983da7866919980f7091fdb">claragenomics::cudamapper::IndexHostCopyBase::directions_of_reads</a> () const =0</td></tr>
<tr class="memdesc:ga24fd5715d983da7866919980f7091fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an array of directions in which sketch elements were read (stored on host)  <a href="group__cudamapper.html#ga24fd5715d983da7866919980f7091fdb">More...</a><br /></td></tr>
<tr class="separator:ga24fd5715d983da7866919980f7091fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58f1203dd96fbbaaa5bdb0bd041f1457"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; representation_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga58f1203dd96fbbaaa5bdb0bd041f1457">claragenomics::cudamapper::IndexHostCopyBase::unique_representations</a> () const =0</td></tr>
<tr class="memdesc:ga58f1203dd96fbbaaa5bdb0bd041f1457"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an array where each representation is recorded only once, sorted by representation (stored on host)  <a href="group__cudamapper.html#ga58f1203dd96fbbaaa5bdb0bd041f1457">More...</a><br /></td></tr>
<tr class="separator:ga58f1203dd96fbbaaa5bdb0bd041f1457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga999355e025c242924f7a15a21242f78b"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; std::uint32_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga999355e025c242924f7a15a21242f78b">claragenomics::cudamapper::IndexHostCopyBase::first_occurrence_of_representations</a> () const =0</td></tr>
<tr class="memdesc:ga999355e025c242924f7a15a21242f78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns first occurrence of corresponding representation from <a class="el" href="group__cudamapper.html#ga58f1203dd96fbbaaa5bdb0bd041f1457" title="returns an array where each representation is recorded only once, sorted by representation (stored on...">unique_representations()</a>, plus one more element with the total number of sketch elements (stored on host)  <a href="group__cudamapper.html#ga999355e025c242924f7a15a21242f78b">More...</a><br /></td></tr>
<tr class="separator:ga999355e025c242924f7a15a21242f78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad447876d56eefefbe6ea62102bd46fc5"><td class="memItemLeft" align="right" valign="top">virtual read_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#gad447876d56eefefbe6ea62102bd46fc5">claragenomics::cudamapper::IndexHostCopyBase::number_of_reads</a> () const =0</td></tr>
<tr class="memdesc:gad447876d56eefefbe6ea62102bd46fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns number of reads in input data  <a href="group__cudamapper.html#gad447876d56eefefbe6ea62102bd46fc5">More...</a><br /></td></tr>
<tr class="separator:gad447876d56eefefbe6ea62102bd46fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bb89013c962501fdb16112c6842a322"><td class="memItemLeft" align="right" valign="top">virtual position_in_read_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga2bb89013c962501fdb16112c6842a322">claragenomics::cudamapper::IndexHostCopyBase::number_of_basepairs_in_longest_read</a> () const =0</td></tr>
<tr class="memdesc:ga2bb89013c962501fdb16112c6842a322"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns length of the longest read in this index  <a href="group__cudamapper.html#ga2bb89013c962501fdb16112c6842a322">More...</a><br /></td></tr>
<tr class="separator:ga2bb89013c962501fdb16112c6842a322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaade347383d4c647517f4269d5ae6ca1f"><td class="memItemLeft" align="right" valign="top">virtual read_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#gaade347383d4c647517f4269d5ae6ca1f">claragenomics::cudamapper::IndexHostCopyBase::first_read_id</a> () const =0</td></tr>
<tr class="memdesc:gaade347383d4c647517f4269d5ae6ca1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns stored value in first_read_id_ representing smallest read_id in index  <a href="group__cudamapper.html#gaade347383d4c647517f4269d5ae6ca1f">More...</a><br /></td></tr>
<tr class="separator:gaade347383d4c647517f4269d5ae6ca1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83dca65a7bf49161135dd60e68acc51b"><td class="memItemLeft" align="right" valign="top">virtual std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga83dca65a7bf49161135dd60e68acc51b">claragenomics::cudamapper::IndexHostCopyBase::kmer_size</a> () const =0</td></tr>
<tr class="memdesc:ga83dca65a7bf49161135dd60e68acc51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns k-mer size  <a href="group__cudamapper.html#ga83dca65a7bf49161135dd60e68acc51b">More...</a><br /></td></tr>
<tr class="separator:ga83dca65a7bf49161135dd60e68acc51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a095c425123e12e1e3061b4bb850b11"><td class="memItemLeft" align="right" valign="top">virtual std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga6a095c425123e12e1e3061b4bb850b11">claragenomics::cudamapper::IndexHostCopyBase::window_size</a> () const =0</td></tr>
<tr class="memdesc:ga6a095c425123e12e1e3061b4bb850b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns window size  <a href="group__cudamapper.html#ga6a095c425123e12e1e3061b4bb850b11">More...</a><br /></td></tr>
<tr class="separator:ga6a095c425123e12e1e3061b4bb850b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58547a7a49e9d0fc6f3473ef73b6a30e"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classclaragenomics_1_1cudamapper_1_1IndexHostCopyBase.html">IndexHostCopyBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga58547a7a49e9d0fc6f3473ef73b6a30e">claragenomics::cudamapper::IndexHostCopyBase::create_cache</a> (const <a class="el" href="classclaragenomics_1_1cudamapper_1_1Index.html">Index</a> &amp;index, const read_id_t <a class="el" href="group__cudamapper.html#gaade347383d4c647517f4269d5ae6ca1f">first_read_id</a>, const std::uint64_t <a class="el" href="group__cudamapper.html#ga83dca65a7bf49161135dd60e68acc51b">kmer_size</a>, const std::uint64_t <a class="el" href="group__cudamapper.html#ga6a095c425123e12e1e3061b4bb850b11">window_size</a>, const cudaStream_t cuda_stream=0)</td></tr>
<tr class="memdesc:ga58547a7a49e9d0fc6f3473ef73b6a30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="group__cudamapper.html#ga58547a7a49e9d0fc6f3473ef73b6a30e">More...</a><br /></td></tr>
<tr class="separator:ga58547a7a49e9d0fc6f3473ef73b6a30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga569c8855bdf9806d3747b26fc7e98975"><td class="memItemLeft" align="right" valign="top"><a id="ga569c8855bdf9806d3747b26fc7e98975"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga569c8855bdf9806d3747b26fc7e98975">claragenomics::cudamapper::Overlapper::~Overlapper</a> ()=default</td></tr>
<tr class="memdesc:ga569c8855bdf9806d3747b26fc7e98975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor for <a class="el" href="classclaragenomics_1_1cudamapper_1_1Overlapper.html">Overlapper</a>. <br /></td></tr>
<tr class="separator:ga569c8855bdf9806d3747b26fc7e98975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a91e2620221bc43709c3de1f3f10631"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga8a91e2620221bc43709c3de1f3f10631">claragenomics::cudamapper::Overlapper::get_overlaps</a> (std::vector&lt; <a class="el" href="structclaragenomics_1_1cudamapper_1_1Overlap.html">Overlap</a> &gt; &amp;fused_overlaps, const <a class="el" href="classclaragenomics_1_1buffer.html">device_buffer</a>&lt; <a class="el" href="structclaragenomics_1_1cudamapper_1_1Anchor.html">Anchor</a> &gt; &amp;d_anchors, int64_t min_residues, int64_t min_overlap_len, int64_t min_bases_per_residue, float min_overlap_fraction)=0</td></tr>
<tr class="memdesc:ga8a91e2620221bc43709c3de1f3f10631"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns overlaps for a set of reads  <a href="group__cudamapper.html#ga8a91e2620221bc43709c3de1f3f10631">More...</a><br /></td></tr>
<tr class="separator:ga8a91e2620221bc43709c3de1f3f10631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa345b5474fb44bed4592785ee51d08c6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#gaa345b5474fb44bed4592785ee51d08c6">claragenomics::cudamapper::Overlapper::print_paf</a> (const std::vector&lt; <a class="el" href="structclaragenomics_1_1cudamapper_1_1Overlap.html">Overlap</a> &gt; &amp;overlaps, const std::vector&lt; std::string &gt; &amp;cigar, const int k)</td></tr>
<tr class="memdesc:gaa345b5474fb44bed4592785ee51d08c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints overlaps to stdout in <a href="https://github.com/lh3/miniasm/blob/master/PAF.md">PAF format</a>  <a href="group__cudamapper.html#gaa345b5474fb44bed4592785ee51d08c6">More...</a><br /></td></tr>
<tr class="separator:gaa345b5474fb44bed4592785ee51d08c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3c81669522c2642ba340d10da5be336"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#gac3c81669522c2642ba340d10da5be336">claragenomics::cudamapper::Overlapper::filter_overlaps</a> (std::vector&lt; <a class="el" href="structclaragenomics_1_1cudamapper_1_1Overlap.html">Overlap</a> &gt; &amp;filtered_overlaps, const std::vector&lt; <a class="el" href="structclaragenomics_1_1cudamapper_1_1Overlap.html">Overlap</a> &gt; &amp;overlaps, int64_t min_residues=20, int64_t min_overlap_len=50)</td></tr>
<tr class="memdesc:gac3c81669522c2642ba340d10da5be336"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes overlaps which are unlikely to be true overlaps  <a href="group__cudamapper.html#gac3c81669522c2642ba340d10da5be336">More...</a><br /></td></tr>
<tr class="separator:gac3c81669522c2642ba340d10da5be336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56522be7d76cf6333feaa7a311448e1f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga56522be7d76cf6333feaa7a311448e1f">claragenomics::cudamapper::Overlapper::update_read_names</a> (std::vector&lt; <a class="el" href="structclaragenomics_1_1cudamapper_1_1Overlap.html">Overlap</a> &gt; &amp;overlaps, const <a class="el" href="classclaragenomics_1_1io_1_1FastaParser.html">io::FastaParser</a> &amp;query_parser, const <a class="el" href="classclaragenomics_1_1io_1_1FastaParser.html">io::FastaParser</a> &amp;target_parser)</td></tr>
<tr class="memdesc:ga56522be7d76cf6333feaa7a311448e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates read names for vector of overlaps output from get_overlaps  <a href="group__cudamapper.html#ga56522be7d76cf6333feaa7a311448e1f">More...</a><br /></td></tr>
<tr class="separator:ga56522be7d76cf6333feaa7a311448e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01239ec382156e8b5a7ae1a98ad6afb4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudamapper.html#ga01239ec382156e8b5a7ae1a98ad6afb4">claragenomics::cudamapper::Overlapper::post_process_overlaps</a> (std::vector&lt; <a class="el" href="structclaragenomics_1_1cudamapper_1_1Overlap.html">Overlap</a> &gt; &amp;overlaps)</td></tr>
<tr class="memdesc:ga01239ec382156e8b5a7ae1a98ad6afb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identified overlaps which can be combined into a larger overlap and add them to the input vector.  <a href="group__cudamapper.html#ga01239ec382156e8b5a7ae1a98ad6afb4">More...</a><br /></td></tr>
<tr class="separator:ga01239ec382156e8b5a7ae1a98ad6afb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Base docs for the cudamapper package (tbd) </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae4ae4c5e439c3a607a07b5fa3e5ee7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4ae4c5e439c3a607a07b5fa3e5ee7a7">&#9670;&nbsp;</a></span>copy_index_to_device()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classclaragenomics_1_1cudamapper_1_1Index.html">Index</a>&gt; claragenomics::cudamapper::IndexHostCopyBase::copy_index_to_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclaragenomics_1_1CudaMallocAllocator.html">DefaultDeviceAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cudaStream_t&#160;</td>
          <td class="paramname"><em>cuda_stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy cached index vectors from the host and create an object of <a class="el" href="classclaragenomics_1_1cudamapper_1_1Index.html" title="Index - manages mapping of (k,w)-kmer-representation and all its occurences.">Index</a> on GPU </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>asynchronous device allocator used for temporary buffer allocations </td></tr>
    <tr><td class="paramname">cuda_stream</td><td>H2D copy is done on this stream. Device arrays are also associated with this stream and will not be freed at least until all work issued on this stream before calling their destructor is done </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to <a class="el" href="classclaragenomics_1_1cudamapper_1_1Index.html" title="Index - manages mapping of (k,w)-kmer-representation and all its occurences.">claragenomics::cudamapper::Index</a> </dd></dl>

</div>
</div>
<a id="ga58547a7a49e9d0fc6f3473ef73b6a30e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58547a7a49e9d0fc6f3473ef73b6a30e">&#9670;&nbsp;</a></span>create_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt;<a class="el" href="classclaragenomics_1_1cudamapper_1_1IndexHostCopyBase.html">IndexHostCopyBase</a>&gt; claragenomics::cudamapper::IndexHostCopyBase::create_cache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclaragenomics_1_1cudamapper_1_1Index.html">Index</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const read_id_t&#160;</td>
          <td class="paramname"><em>first_read_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::uint64_t&#160;</td>
          <td class="paramname"><em>kmer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::uint64_t&#160;</td>
          <td class="paramname"><em>window_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cudaStream_t&#160;</td>
          <td class="paramname"><em>cuda_stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>creates a copy of input processed index on the host </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>- pointer to computed index parameters (vectors of sketch elements) on GPU </td></tr>
    <tr><td class="paramname">first_read_id</td><td>- representing smallest read_id in index </td></tr>
    <tr><td class="paramname">kmer_size</td><td>- number of basepairs in a k-mer </td></tr>
    <tr><td class="paramname">window_size</td><td>the number of adjacent k-mers in a window, adjacent = shifted by one basepair </td></tr>
    <tr><td class="paramname">cuda_stream</td><td>D2H copy is done on this stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- an instance of <a class="el" href="classclaragenomics_1_1cudamapper_1_1IndexHostCopyBase.html">IndexHostCopyBase</a> </dd></dl>

</div>
</div>
<a id="gab4bfb3b8417c5bfd89ae66c6d2a041ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4bfb3b8417c5bfd89ae66c6d2a041ba">&#9670;&nbsp;</a></span>create_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt;<a class="el" href="classclaragenomics_1_1cudamapper_1_1Index.html">Index</a>&gt; claragenomics::cudamapper::Index::create_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclaragenomics_1_1CudaMallocAllocator.html">DefaultDeviceAllocator</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclaragenomics_1_1io_1_1FastaParser.html">io::FastaParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const read_id_t&#160;</td>
          <td class="paramname"><em>first_read_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const read_id_t&#160;</td>
          <td class="paramname"><em>past_the_last_read_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::uint64_t&#160;</td>
          <td class="paramname"><em>kmer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::uint64_t&#160;</td>
          <td class="paramname"><em>window_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>hash_representations</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>filtering_parameter</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cudaStream_t&#160;</td>
          <td class="paramname"><em>cuda_stream</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>generates a mapping of (k,w)-kmer-representation to all of its occurrences for one or more sequences </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The device memory allocator to use for temporary buffer allocations </td></tr>
    <tr><td class="paramname">parser</td><td>parser for the whole input file (part that goes into this index is determined by first_read_id and past_the_last_read_id) </td></tr>
    <tr><td class="paramname">first_read_id</td><td>read_id of the first read to the included in this index </td></tr>
    <tr><td class="paramname">past_the_last_read_id</td><td>read_id+1 of the last read to be included in this index </td></tr>
    <tr><td class="paramname">kmer_size</td><td>k - the kmer length </td></tr>
    <tr><td class="paramname">window_size</td><td>w - the length of the sliding window used to find sketch elements (i.e. the number of adjacent kmers in a window, adjacent = shifted by one basepair) </td></tr>
    <tr><td class="paramname">hash_representations</td><td>if true, hash kmer representations </td></tr>
    <tr><td class="paramname">filtering_parameter</td><td>filter out all representations for which number_of_sketch_elements_with_that_representation/total_skech_elements &gt;= filtering_parameter, filtering_parameter == 1.0 disables filtering </td></tr>
    <tr><td class="paramname">cuda_stream</td><td>CUDA stream on which the work is to be done. Device arrays are also associated with this stream and will not be freed at least until all work issued on this stream before calling their destructor is done </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>instance of <a class="el" href="classclaragenomics_1_1cudamapper_1_1Index.html" title="Index - manages mapping of (k,w)-kmer-representation and all its occurences.">Index</a> </dd></dl>

</div>
</div>
<a id="ga65817f40ba793c63c356fb97caff9522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65817f40ba793c63c356fb97caff9522">&#9670;&nbsp;</a></span>directions_of_reads() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classclaragenomics_1_1buffer.html">device_buffer</a>&lt;<a class="el" href="classclaragenomics_1_1cudamapper_1_1SketchElement.html#a83beb5c091c4b0bfec99c04b6bc8777a">SketchElement::DirectionOfRepresentation</a>&gt;&amp; claragenomics::cudamapper::Index::directions_of_reads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an array of directions in which sketch elements were read </p>
<dl class="section return"><dt>Returns</dt><dd>an array of directions in which sketch elements were read </dd></dl>

</div>
</div>
<a id="ga24fd5715d983da7866919980f7091fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24fd5715d983da7866919980f7091fdb">&#9670;&nbsp;</a></span>directions_of_reads() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::vector&lt;<a class="el" href="classclaragenomics_1_1cudamapper_1_1SketchElement.html#a83beb5c091c4b0bfec99c04b6bc8777a">SketchElement::DirectionOfRepresentation</a>&gt;&amp; claragenomics::cudamapper::IndexHostCopyBase::directions_of_reads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an array of directions in which sketch elements were read (stored on host) </p>
<dl class="section return"><dt>Returns</dt><dd>an array of directions in which sketch elements were read </dd></dl>

</div>
</div>
<a id="gac3c81669522c2642ba340d10da5be336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3c81669522c2642ba340d10da5be336">&#9670;&nbsp;</a></span>filter_overlaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void claragenomics::cudamapper::Overlapper::filter_overlaps </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structclaragenomics_1_1cudamapper_1_1Overlap.html">Overlap</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>filtered_overlaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structclaragenomics_1_1cudamapper_1_1Overlap.html">Overlap</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>overlaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_residues</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_overlap_len</em> = <code>50</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>removes overlaps which are unlikely to be true overlaps </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filtered_overlaps</td><td>Output vector in which to place filtered overlaps </td></tr>
    <tr><td class="paramname">overlaps</td><td>vector of <a class="el" href="structclaragenomics_1_1cudamapper_1_1Overlap.html">Overlap</a> objects to be filtered </td></tr>
    <tr><td class="paramname">min_residues</td><td>smallest number of residues (anchors) for an overlap to be accepted </td></tr>
    <tr><td class="paramname">min_overlap_len</td><td>the smallest overlap distance which is accepted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga23503e693b8c804a14e6f773a2a8f6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23503e693b8c804a14e6f773a2a8f6e4">&#9670;&nbsp;</a></span>first_occurrence_of_representations() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classclaragenomics_1_1buffer.html">device_buffer</a>&lt;std::uint32_t&gt;&amp; claragenomics::cudamapper::Index::first_occurrence_of_representations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns first occurrence of corresponding representation from <a class="el" href="group__cudamapper.html#ga9c0fe1c2988d7c9f0c652909b0f0f6e7" title="returns an array where each representation is recorder only once, sorted by representation">unique_representations()</a> in data arrays </p>
<dl class="section return"><dt>Returns</dt><dd>first occurrence of corresponding representation from <a class="el" href="group__cudamapper.html#ga9c0fe1c2988d7c9f0c652909b0f0f6e7" title="returns an array where each representation is recorder only once, sorted by representation">unique_representations()</a> in data arrays </dd></dl>

</div>
</div>
<a id="ga999355e025c242924f7a15a21242f78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga999355e025c242924f7a15a21242f78b">&#9670;&nbsp;</a></span>first_occurrence_of_representations() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::vector&lt;std::uint32_t&gt;&amp; claragenomics::cudamapper::IndexHostCopyBase::first_occurrence_of_representations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns first occurrence of corresponding representation from <a class="el" href="group__cudamapper.html#ga58f1203dd96fbbaaa5bdb0bd041f1457" title="returns an array where each representation is recorded only once, sorted by representation (stored on...">unique_representations()</a>, plus one more element with the total number of sketch elements (stored on host) </p>
<dl class="section return"><dt>Returns</dt><dd>first occurrence of corresponding representation from <a class="el" href="group__cudamapper.html#ga58f1203dd96fbbaaa5bdb0bd041f1457" title="returns an array where each representation is recorded only once, sorted by representation (stored on...">unique_representations()</a>, plus one more element with the total number of sketch elements </dd></dl>

</div>
</div>
<a id="gaade347383d4c647517f4269d5ae6ca1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaade347383d4c647517f4269d5ae6ca1f">&#9670;&nbsp;</a></span>first_read_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual read_id_t claragenomics::cudamapper::IndexHostCopyBase::first_read_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns stored value in first_read_id_ representing smallest read_id in index </p>
<dl class="section return"><dt>Returns</dt><dd>first_read_id_ </dd></dl>

</div>
</div>
<a id="ga8a91e2620221bc43709c3de1f3f10631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a91e2620221bc43709c3de1f3f10631">&#9670;&nbsp;</a></span>get_overlaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void claragenomics::cudamapper::Overlapper::get_overlaps </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structclaragenomics_1_1cudamapper_1_1Overlap.html">Overlap</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fused_overlaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclaragenomics_1_1buffer.html">device_buffer</a>&lt; <a class="el" href="structclaragenomics_1_1cudamapper_1_1Anchor.html">Anchor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_anchors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_residues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_overlap_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_bases_per_residue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_overlap_fraction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns overlaps for a set of reads </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fused_overlaps</td><td>Output vector into which generated overlaps will be placed </td></tr>
    <tr><td class="paramname">d_anchors</td><td>vector of anchors sorted by query_read_id -&gt; target_read_id -&gt; query_position_in_read -&gt; target_position_in_read (meaning sorted by query_read_id, then within a group of anchors with the same value of query_read_id sorted by target_read_id and so on) </td></tr>
    <tr><td class="paramname">min_residues</td><td>smallest number of residues (anchors) for an overlap to be accepted </td></tr>
    <tr><td class="paramname">min_overlap_len</td><td>the smallest overlap distance which is accepted </td></tr>
    <tr><td class="paramname">min_bases_per_residue</td><td>the minimum number of nucleotides per residue (e.g minimizer) in an overlap </td></tr>
    <tr><td class="paramname">min_overlap_fraction</td><td>the minimum ratio between the shortest and longest of the target and query components of an overlap. e.g if Query range is (150,1000) and target range is (1000,2000) then overlap fraction is 0.85 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga83dca65a7bf49161135dd60e68acc51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83dca65a7bf49161135dd60e68acc51b">&#9670;&nbsp;</a></span>kmer_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::uint64_t claragenomics::cudamapper::IndexHostCopyBase::kmer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns k-mer size </p>
<dl class="section return"><dt>Returns</dt><dd>kmer_size_ </dd></dl>

</div>
</div>
<a id="gad4806eed2d87f879fe2ff10e1bf1cc76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4806eed2d87f879fe2ff10e1bf1cc76">&#9670;&nbsp;</a></span>largest_read_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual read_id_t claragenomics::cudamapper::Index::largest_read_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns largest read_id in index </p>
<dl class="section return"><dt>Returns</dt><dd>largest read_id in index (0 if empty index) </dd></dl>

</div>
</div>
<a id="gaf9247d4b637615bf5912acc57b27b919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9247d4b637615bf5912acc57b27b919">&#9670;&nbsp;</a></span>maximum_kmer_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t claragenomics::cudamapper::Index::maximum_kmer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum kmer length allowable. </p>
<dl class="section return"><dt>Returns</dt><dd>Return the maximum kmer length allowable </dd></dl>

</div>
</div>
<a id="ga8d82b107e7846ef2714b728af83b8a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d82b107e7846ef2714b728af83b8a0a">&#9670;&nbsp;</a></span>number_of_basepairs_in_longest_read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual position_in_read_t claragenomics::cudamapper::Index::number_of_basepairs_in_longest_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns length of the longest read in this index </p>
<dl class="section return"><dt>Returns</dt><dd>length of the longest read in this index </dd></dl>

</div>
</div>
<a id="ga2bb89013c962501fdb16112c6842a322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bb89013c962501fdb16112c6842a322">&#9670;&nbsp;</a></span>number_of_basepairs_in_longest_read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual position_in_read_t claragenomics::cudamapper::IndexHostCopyBase::number_of_basepairs_in_longest_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns length of the longest read in this index </p>
<dl class="section return"><dt>Returns</dt><dd>length of the longest read in this index </dd></dl>

</div>
</div>
<a id="ga23208afd4c7438a24a45cdb9cdf24dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23208afd4c7438a24a45cdb9cdf24dee">&#9670;&nbsp;</a></span>number_of_reads() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual read_id_t claragenomics::cudamapper::Index::number_of_reads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns number of reads in input data </p>
<dl class="section return"><dt>Returns</dt><dd>number of reads in input data </dd></dl>

</div>
</div>
<a id="gad447876d56eefefbe6ea62102bd46fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad447876d56eefefbe6ea62102bd46fc5">&#9670;&nbsp;</a></span>number_of_reads() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual read_id_t claragenomics::cudamapper::IndexHostCopyBase::number_of_reads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns number of reads in input data </p>
<dl class="section return"><dt>Returns</dt><dd>number of reads in input data </dd></dl>

</div>
</div>
<a id="ga6ea546f53cd32cf6ebf1ce02fbaf8fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ea546f53cd32cf6ebf1ce02fbaf8fce">&#9670;&nbsp;</a></span>positions_in_reads() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classclaragenomics_1_1buffer.html">device_buffer</a>&lt;position_in_read_t&gt;&amp; claragenomics::cudamapper::Index::positions_in_reads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an array of starting positions of sketch elements in their reads </p>
<dl class="section return"><dt>Returns</dt><dd>an array of starting positions of sketch elements in their reads </dd></dl>

</div>
</div>
<a id="ga6e305008b43cecb83f9996d53a7c8441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e305008b43cecb83f9996d53a7c8441">&#9670;&nbsp;</a></span>positions_in_reads() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::vector&lt;position_in_read_t&gt;&amp; claragenomics::cudamapper::IndexHostCopyBase::positions_in_reads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an array of starting positions of sketch elements in their reads (stored on host) </p>
<dl class="section return"><dt>Returns</dt><dd>an array of starting positions of sketch elements in their reads </dd></dl>

</div>
</div>
<a id="ga01239ec382156e8b5a7ae1a98ad6afb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01239ec382156e8b5a7ae1a98ad6afb4">&#9670;&nbsp;</a></span>post_process_overlaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void claragenomics::cudamapper::Overlapper::post_process_overlaps </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structclaragenomics_1_1cudamapper_1_1Overlap.html">Overlap</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>overlaps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identified overlaps which can be combined into a larger overlap and add them to the input vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overlaps</td><td>reference to vector of Overlaps. New overlaps (result of fusing) are added to this vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa345b5474fb44bed4592785ee51d08c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa345b5474fb44bed4592785ee51d08c6">&#9670;&nbsp;</a></span>print_paf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void claragenomics::cudamapper::Overlapper::print_paf </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structclaragenomics_1_1cudamapper_1_1Overlap.html">Overlap</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>overlaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>cigar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>prints overlaps to stdout in <a href="https://github.com/lh3/miniasm/blob/master/PAF.md">PAF format</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overlaps</td><td>vector of overlap objects </td></tr>
    <tr><td class="paramname">cigar</td><td>cigar strings </td></tr>
    <tr><td class="paramname">k</td><td>minimizer kmer size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga104c899ad0522ea91786994b63470e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga104c899ad0522ea91786994b63470e8f">&#9670;&nbsp;</a></span>read_ids() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classclaragenomics_1_1buffer.html">device_buffer</a>&lt;read_id_t&gt;&amp; claragenomics::cudamapper::Index::read_ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an array of reads ids for sketch elements </p>
<dl class="section return"><dt>Returns</dt><dd>an array of reads ids for sketch elements </dd></dl>

</div>
</div>
<a id="ga9be5f568a1a29a571e4bf235673fa32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9be5f568a1a29a571e4bf235673fa32c">&#9670;&nbsp;</a></span>read_ids() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::vector&lt;read_id_t&gt;&amp; claragenomics::cudamapper::IndexHostCopyBase::read_ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an array of reads ids for sketch elements (stored on host) </p>
<dl class="section return"><dt>Returns</dt><dd>an array of reads ids for sketch elements </dd></dl>

</div>
</div>
<a id="ga4c15374cb6642179acb57ecc19ecbbd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c15374cb6642179acb57ecc19ecbbd5">&#9670;&nbsp;</a></span>representations() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classclaragenomics_1_1buffer.html">device_buffer</a>&lt;representation_t&gt;&amp; claragenomics::cudamapper::Index::representations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an array of representations of sketch elements </p>
<dl class="section return"><dt>Returns</dt><dd>an array of representations of sketch elements </dd></dl>

</div>
</div>
<a id="ga7adadddfc7a5c1c6e45434145e7266d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7adadddfc7a5c1c6e45434145e7266d2">&#9670;&nbsp;</a></span>representations() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::vector&lt;representation_t&gt;&amp; claragenomics::cudamapper::IndexHostCopyBase::representations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an array of representations of sketch elements (stored on host) </p>
<dl class="section return"><dt>Returns</dt><dd>an array of representations of sketch elements </dd></dl>

</div>
</div>
<a id="ga0e47e8d4eea8b8c48cf7501e1f217dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e47e8d4eea8b8c48cf7501e1f217dd3">&#9670;&nbsp;</a></span>smallest_read_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual read_id_t claragenomics::cudamapper::Index::smallest_read_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns smallest read_id in index </p>
<dl class="section return"><dt>Returns</dt><dd>smallest read_id in index (0 if empty index) </dd></dl>

</div>
</div>
<a id="ga9c0fe1c2988d7c9f0c652909b0f0f6e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c0fe1c2988d7c9f0c652909b0f0f6e7">&#9670;&nbsp;</a></span>unique_representations() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classclaragenomics_1_1buffer.html">device_buffer</a>&lt;representation_t&gt;&amp; claragenomics::cudamapper::Index::unique_representations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an array where each representation is recorder only once, sorted by representation </p>
<dl class="section return"><dt>Returns</dt><dd>an array where each representation is recorder only once, sorted by representation </dd></dl>

</div>
</div>
<a id="ga58f1203dd96fbbaaa5bdb0bd041f1457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58f1203dd96fbbaaa5bdb0bd041f1457">&#9670;&nbsp;</a></span>unique_representations() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::vector&lt;representation_t&gt;&amp; claragenomics::cudamapper::IndexHostCopyBase::unique_representations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an array where each representation is recorded only once, sorted by representation (stored on host) </p>
<dl class="section return"><dt>Returns</dt><dd>an array where each representation is recorded only once, sorted by representation </dd></dl>

</div>
</div>
<a id="ga56522be7d76cf6333feaa7a311448e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56522be7d76cf6333feaa7a311448e1f">&#9670;&nbsp;</a></span>update_read_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void claragenomics::cudamapper::Overlapper::update_read_names </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structclaragenomics_1_1cudamapper_1_1Overlap.html">Overlap</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>overlaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclaragenomics_1_1io_1_1FastaParser.html">io::FastaParser</a> &amp;&#160;</td>
          <td class="paramname"><em>query_parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclaragenomics_1_1io_1_1FastaParser.html">io::FastaParser</a> &amp;&#160;</td>
          <td class="paramname"><em>target_parser</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>updates read names for vector of overlaps output from get_overlaps </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overlaps</td><td>input vector of overlaps generated in get_overlaps </td></tr>
    <tr><td class="paramname">query_parser</td><td>needed for read names and lenghts </td></tr>
    <tr><td class="paramname">target_parser</td><td>needed for read names and lenghts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6a095c425123e12e1e3061b4bb850b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a095c425123e12e1e3061b4bb850b11">&#9670;&nbsp;</a></span>window_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::uint64_t claragenomics::cudamapper::IndexHostCopyBase::window_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns window size </p>
<dl class="section return"><dt>Returns</dt><dd>window_size_ </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
